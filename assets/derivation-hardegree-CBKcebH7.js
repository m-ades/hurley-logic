var D=Object.defineProperty;var T=(g,t,s)=>t in g?D(g,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):g[t]=s;var E=(g,t,s)=>T(g,typeof t!="symbol"?t+"":t,s);import{g as M,a as _,j as S,p as q,b as R}from"./index-R-LGsi0F.js";const O={};function U(g){const s=class s{constructor(e){this.parsedstr=e,this._syntaxerrors={}}get allpletters(){if("_allpletters"in this)return this._allpletters;const e=this.left?this.left.allpletters:[],i=this.right?this.right.allpletters:[];return this.pletter&&i.push(this.pletter),this._allpletters=_(e,i),this._allpletters}get boundvar(){if("_boundvar"in this)return this._boundvar;if(!s.syntax.isquant(this.op))return this._boundvar=!1,this._boundvar;const e=this.parsedstr.match(s.syntax.qaRegEx);if(e){const i=e[0].match(s.syntax.varRegEx);if(i)return this._boundvar=i[0],this._boundvar}return this._boundvar=!1,this.syntaxError("a quantifier is used without a variable in the range "+s.syntax.notation.variableRange+" following it or has stray characters before it"),this._boundvar}get depth(){return"_depth"in this?this._depth:s.syntax.isbinaryop(this.op)?(this._depth=Math.max(this.left.depth,this.right.depth)+1,this._depth):s.syntax.ismonop(this.op)?(this._depth=this.right.depth,this.depth):(this._depth=0,this._depth)}get freevars(){if("_freevars"in this)return this._freevars;if(s.syntax.isbinaryop(this.op)){const e=this.left?this.left.freevars:[],i=this.right?this.right.freevars:[];return this._freevars=_(e,i),this._freevars}if(s.syntax.isquant(this.op)){let i=this.right?this.right.freevars:[];return this.boundvar&&(i=i.filter(n=>n!=this.boundvar)),this._freevars=i,this._freevars}return s.syntax.ismonop(this.op)?(this._freevars=this.right?this.right.freevars:[],this._freevars):this.op?(this._freevars=[],this._freevars):(this._freevars=this.terms.filter(e=>s.syntax.isvar(e)),this._freevars)}get left(){if("_left"in this)return this._left;if(this.opspot<1)return s.syntax.isbinaryop(this.op)&&this.syntaxError("nothing to the left of "+this.op),this._left=!1,this._left;const e=this.parsedstr.substring(0,this.opspot).trim();return this._left=s.from(e),this._left}get normal(){var u,p,c;if("_normal"in this)return this._normal;let e="";this.left&&(s.syntax.isbinaryop(this.left.op)?e=this.left.wrapit():e=this.left.normal);let i="";if(this.right&&(s.syntax.isbinaryop(this.right.op)?i=this.right.wrapit():i=this.right.normal),s.syntax.isbinaryop(this.op))return this._normal=e+" "+this.op+" "+i,this._normal;if(s.syntax.ismonop(this.op)){let f=this.op;if(s.syntax.isquant(f)){let m=this.boundvar??"";f=s.syntax.mkquantifier(m,f)}return!((u=this==null?void 0:this.right)!=null&&u.op)&&(((p=this==null?void 0:this.right)==null?void 0:p.pletter)=="="||((c=this==null?void 0:this.right)==null?void 0:c.pletter)=="≠")?(this._normal=f+"("+i+")",this._normal):(this._normal=f+i,this._normal)}if(this.op)return this._normal=this.op,this._normal;const n=this.terms??[],o=this.pletter??"";let h="";s.syntax.notation.useTermParensCommas&&(h=",");let a=this.terms.join(h);s.syntax.notation.useTermParensCommas&&this.terms.length>0&&(a="("+a+")");let l=o+a;return n.length==2&&(o=="="||o=="≠")&&(l=this.terms[0]+" "+o+" "+this.terms[1]),this._normal=l,this._normal}get op(){if(!this.parsedstr)return!1;if("_op"in this)return this._op;const e=this.opspot;if(e==-1)return!1;if(this.parsedstr[e]in s.syntax.operators)return this._op=this.parsedstr[e],this._op;const n=this.parsedstr.substring(this.opspot).match(s.syntax.qaRegEx);return n?n[0].search(s.syntax.symbols.EXISTS)>=0?(this._op=s.syntax.symbols.EXISTS,this._op):(this._op=s.syntax.symbols.FORALL,this._op):(this._op=!1,this._op)}get opspot(){if("_opspot"in this)return this._opspot;const e=s.syntax.notation.quantifierForm.indexOf("(")!=-1,i=(()=>{const c=this.parsedstr.match(s.syntax.qaRegEx);return c&&c[0].startsWith("(")&&c[0].endsWith(")")})();this._opspot=-1;let n=0,o=-1,h=-1,a=0;const l={"(":")","[":"]","{":"}"},u={")":"(","]":"[","}":"{"},p=[];for(let c=0;c<this.parsedstr.length;c++){const f=this.parsedstr.at(c),m=this.parsedstr.substring(c);c==0||this.parsedstr.at(c-1),l[f]?(n++,a++,p.push(f)):u[f]&&((p.length==0||p.pop()!=u[f])&&this.syntaxError("unbalanced parentheses (mismatched brackets)"),n--,a--),n<0&&this.syntaxError("unbalanced parentheses (extra right parenthesis)");let d=s.syntax.isop(f),y=m.match(s.syntax.qaRegEx);(e||i)&&f==s.syntax.symbols.EXISTS&&!y&&(d=!1);const v=y&&(e||i)?n-1:n;let b=f;if(y){let x=y[0];x.match(new RegExp("^\\(["+s.syntax.notation.variableRange+"]\\)$"))?b=s.syntax.symbols.FORALL:x.search(s.syntax.symbols.EXISTS)>=0?b=s.syntax.symbols.EXISTS:b=s.syntax.symbols.FORALL}if(d||y){const x=s.syntax.symbolcat[s.syntax.operators[b]];v<o||o==-1?(this._opspot=c,o=v,h=x):v==o&&(x==2&&h==2&&this.syntaxError("two binary operators occur without enough parentheses to determine which has wider scope"),x>h&&(this._opspot=c,o=v,h=x))}}return a>0&&this.syntaxError("unbalanced parentheses (unclosed left parenthesis)"),a<0&&this.syntaxError("unbalanced parentheses (extra right parenthesis)"),this._opspot}get pletter(){if("_pletter"in this)return this._pletter;if(this.op)return this._pletter=!1,this._pletter;const e=this.parsedstr.match(s.syntax.pletterRegEx);if(!e)return this._pletter=!1,this.syntaxError("an atomic (sub)formula must use a letter in the range "+s.syntax.notation.predicatesRange+" and this does not"),this._pletter;this._pletter=e[0];const i=e.index;return i!=0&&this._pletter!="="&&this._pletter!="≠"&&this.syntaxError("unexpected characters appear before the letter "+this._pletter),i!=2&&this._pletter=="="&&this.syntaxError("the identity relation symbol = occurs in an unexpected place"),i!=2&&this._pletter=="≠"&&this.syntaxError("the nonidentity symbol ≠ occurs in an unexpected place"),this._pletter}get right(){if("_right"in this)return this._right;if(this.opspot==-1||s.syntax.symbolcat[s.syntax.operators[this.op]]==0)return this._right=!1,this._right;let e=1;if(s.syntax.isquant(this.op)){let n=this.parsedstr.match(s.syntax.qaRegEx);n&&(e=n[0].length)}const i=this.parsedstr.substring(this.opspot+e).trim();return i==""?(this.syntaxError("nothing to the right of the operator "+this.op),this._right=!1,this._right):(this._right=s.from(i),this._right)}get syntaxerrors(){if(!("_syntaxerrors"in this))return"";let e="",i=!1;for(let n in this._syntaxerrors)this._syntaxerrors[n]&&(i&&(e+="; "),e+=n,i=!0);return e}get terms(){if("_terms"in this)return this._terms;let e=this.parsedstr;this.op||(e=e.replace(this.pletter,"").trim()),e=e.replaceAll(" ","");const i=s.syntax.stripmatching(e);e!=i&&(this._termshadparens=!0);const n=i.replaceAll(",","");return n!=i&&(this._termshadcommas=!0),this._terms=n.match(s.syntax.termsRegEx),this._terms||(this._terms=[]),this._terms}get wellformed(){if("_wellformed"in this)return this._wellformed;if(s.syntax.isbinaryop(this.op)){"_wellformed"in this||(this._wellformed=!0);const e=this.left.wellformed,i=this.right.wellformed;return Object.assign(this._syntaxerrors,this.left._syntaxerrors,this.right._syntaxerrors),this._wellformed=this._wellformed&&e&&i,this._wellformed}if(s.syntax.ismonop(this.op))return"_wellformed"in this||(this._wellformed=!0),this.right.wellformed||(this._wellformed=!1),Object.assign(this._syntaxerrors,this.right._syntaxerrors),this.opspot!=0?(this.syntaxError("unexpected character(s) appear before "+(s.syntax.isquant(this.op)?"a quantifier":"the operator "+this.op)),this._wellformed=!1,this._wellformed):(s.syntax.isquant(this.op)&&(this.boundvar!==!1||(this._wellformed=!1)),this._wellformed);if(this.op)return this.parsedstr!=this.op?(this.syntaxError("unexpected character(s) appear surrounding the symbol "+this.op),this._wellformed=!1,this._wellformed):(this._wellformed=!0,this._wellformed);this._wellformed=!0,this.pletter===!1&&(this._wellformed=!1),this.terms===!1&&(this._wellformed=!1),(this.pletter=="="||this.pletter=="≠")&&this.terms.length!=2&&this.syntaxError("uses the identity predicate “=” or nonindentity predicate “≠” without exactly one term on each side");for(let e in this._syntaxerrors){this._wellformed=!1;break}return this._wellformed}instantiate(e,i){if(s.syntax.isbinaryop(this.op)){if(!this.left||!this.right)return"";const u=s.from(this.left.instantiate(e,i)),p=s.from(this.right.instantiate(e,i));return u.wrapifneeded()+" "+this.op+" "+p.wrapifneeded()}if(s.syntax.ismonop(this.op)){if(!this.right)return"";if(s.syntax.isquant(this.op)&&this.boundvar==e)return this.normal;const u=s.from(this.right.instantiate(e,i));return s.syntax.isquant(this.op)?!this.right.op&&(this.right.pletter=="="||this.right.pletter=="≠")?s.syntax.mkquantifier(this.boundvar,this.op)+"("+u.normal+")":s.syntax.mkquantifier(this.boundvar,this.op)+u.wrapifneeded():!this.right.op&&(this.right.pletter=="="||this.right.pletter=="≠")?this.op+"("+u.normal+")":this.op+u.wrapifneeded()}if(this.op)return this.normal;const n=this.pletter??"",o=(this.terms??[]).map(u=>u==e?i:u);let h="";s.syntax.notation.useTermParensCommas&&(h=",");let a=o.join(h);s.syntax.notation.useTermParensCommas&&o.length>0&&(a="("+a+")");let l=n+a;return o.length==2&&(n=="="||n=="≠")&&(l=o[0]+" "+n+" "+o[1]),l}static differsAtMostBy(e,i,n,o){if(e.op&&!i.op||i.op&&!e.op)return!1;if(e.op&&i.op)return e.op!=i.op?!1:s.syntax.ispropconst(e.op)?!0:s.syntax.isquant(e.op)&&e.boundvar!=i.boundvar||!s.differsAtMostBy(e.right,i.right,n,o)?!1:s.syntax.ismonop(e.op)?!0:s.differsAtMostBy(e.left,i.left,n,o);if(e.pletter!=i.pletter||e.terms.length!=i.terms.length)return!1;for(let h=0;h<e.terms.length;h++){const a=e.terms[h],l=i.terms[h];if(a!=l&&(l!=o||a!=n))return!1}return!0}static isInstanceOf(e,i){if(!i.right)return!1;let n=e.terms;n=n.filter(o=>!s.syntax.isvar(o));for(let o of n)if(e.normal==i.right.instantiate(i.boundvar,o))return!0;return!1}syntaxError(e){this._syntaxerrors[e]=!0,this._wellformed=!1}wrapifneeded(){return this.op&&s.syntax.isbinaryop(this.op)?this.wrapit():this.normal}wrapit(){switch(this.depth%3){case 0:return"{"+this.normal+"}";case 1:return"("+this.normal+")";case 2:return"["+this.normal+"]";default:return this.normal}}};E(s,"repository",{}),E(s,"syntax",M(g)),E(s,"from",function(e){const i=s.syntax.stripmatching(s.syntax.inputfix(e).trim());return s.repository[i]||(s.repository[i]=new s(i)),s.repository[i]});let t=s;return t}function P(g){if(g in O)return O[g];const t=U(g);return O[g]=t,t}class N{constructor(t,s,r,e,i,n=!1,o=!1){E(this,"amts",{high:.2,medium:.15,low:.1});this.notationname=t;const h=P(t);this.Formula=h,this.syntax=h.syntax,this.rules=s,this.deriv=r,this.prems=e.map(a=>h.from(a).normal),this.conc=h.from(i).normal,this.thorough=n,this.pointsportion=1,this.progresslines=0,this.numberedShowLines=o,this.errors={}}adderror(t,s,r,e){return this.errors||(this.errors={}),this.errors[t]||(this.errors[t]={}),this.errors[t][s]||(this.errors[t][s]={}),this.errors[t][s][r]||(this.errors[t][s][r]={}),this.errors[t][s][r][e]?this.errors[t][s][r][e]++:this.errors[t][s][r][e]=1,this.errors}analyze(t){var s,r,e,i;if(t.analyzed)return t;t.lines=[],t.lnmap={},t.assumptions=[],(t.showline&&((s=t.showline)!=null&&s.j)&&((r=t.showline)==null?void 0:r.j)!=""||(e=t.showline)!=null&&e.s&&((i=t.showline)==null?void 0:i.s)!="")&&(t.showline.mysubderiv=t,!t.showline.isMainConclusion&&this.numberedShowLines&&(t.lines.push(t.showline),t.showline.isshowline=!0),t.showline.n&&t.showline.n!=""&&!t.showline.isMainConclusion&&(t.lnmap[t.showline.n]=t.showline));for(let n of t==null?void 0:t.parts){if("parts"in n){n=this.analyze(n),n.parentderiv=t,t.lines=t.lines.concat(n.lines);for(const o in n.lnmap)o in t.lnmap?this.adderror(o,"justification","low","has the same line number as a line another subderivation"):t.lnmap[o]=n.lnmap[o];n.analyzed=!0;continue}n.mysubderiv=t,!((!n.s||n.s=="")&&(!n.j||n.j==""))&&(t.lines.push(n),n.n?n.n in t.lnmap?this.adderror(n.n,"justification","low","has a duplicate line number"):t.lnmap[n.n]=n:this.adderror("??","justification","low","not all lines have line numbers"))}return t}checkConc(){let t=!1;const s=this.Formula,r=e=>{if(!e)return!1;if(e.lines&&Array.isArray(e.lines)){for(const i of e.lines)if(i&&i.s)try{if(s.from(i.s).normal==this.conc)return!0}catch{continue}}if(e.parts&&Array.isArray(e.parts)){for(let i of e.parts)if(i){if(("parts"in i||"lines"in i)&&r(i))return!0;if(i.s)try{if(s.from(i.s).normal==this.conc)return!0}catch{continue}}}return!1};t=r(this.deriv),t||this.adderror("1","completion","high","final conclusion of argument not shown")}checkJustification(t){if(t.isshowline||t.j&&t.j.trim().startsWith("//"))return t;if(!t.j||t.j.trim()==""){const l=this.Formula.from(t.s).normal;return this.prems.includes(l)||this.adderror(t.n,"justification","high","has no justification given"),t}const{nums:s,ranges:r,citedrules:e}=S(t.j);for(const a of s){if(a=="?"){this.adderror(t.n,"justification","low","cites an unknown line number (?)");continue}this.isAvailableLineTo(a,t)}for(const[a,l]of r){if(/[?]/.test(a)||/[?]/.test(l)){this.adderror(t.n,"justification","low","cites a line number range with an unknown line number (?)");continue}this.isAvailableRangeTo(a,l,t)}e.length<1&&this.adderror(t.n,"justification","medium","does not cite a rule"),e.length>1&&this.adderror(t.n,"justification","low","cites more than one rule (only one can be checked)");const i={mp:"MP",Mp:"MP",mP:"MP",mt:"MT",Mt:"MT",mT:"MT",hs:"HS",Hs:"HS",hS:"HS",ds:"DS",Ds:"DS",dS:"DS",simp:"Simp",SIMP:"Simp",SimP:"Simp",sImp:"Simp",conj:"Conj",CONJ:"Conj",ConJ:"Conj",cOnj:"Conj",add:"Add",ADD:"Add",AdD:"Add",aDd:"Add",cd:"CD",Cd:"CD",cD:"CD",dn:"DN",Dn:"DN",dN:"DN",dm:"DM",Dm:"DM",dM:"DM",com:"Com",COM:"Com",CoM:"Com",cOm:"Com",assoc:"Assoc",ASSOC:"Assoc",AsSoC:"Assoc",dist:"Dist",DIST:"Dist",DiSt:"Dist",dIsT:"Dist",trans:"Trans",TRANS:"Trans",TrAnS:"Trans",impl:"Impl",IMPL:"Impl",ImPl:"Impl",iMpL:"Impl",equiv:"Equiv",EQUIV:"Equiv",EqUiV:"Equiv",exp:"Exp",EXP:"Exp",ExP:"Exp",eXp:"Exp",taut:"Taut",TAUT:"Taut",TaUt:"Taut",tAuT:"Taut",ui:"UI",Ui:"UI",uI:"UI",ug:"UG",Ug:"UG",uG:"UG",ei:"EI",Ei:"EI",eI:"EI",eg:"EG",Eg:"EG",eG:"EG",cq:"CQ",Cq:"CQ",cQ:"CQ",qn:"QN",Qn:"QN",qN:"QN",UD:"UG"},n=[];for(const a of e){let l=a;l in i&&(l=i[l]),!(l in this.rules)||this.rules[l].meinongian?this.adderror(t.n,"rule","high","cites a rule ("+a+") that does not exist"):n.push(l)}if(n.length<1)return this.rulechecked=!1,t;const o=n[0],h=this.rules[o];if(t.isshowline&&!h.showrule)return this.adderror(t.n,"justification","high","cites a non-show-rule for a show line"),this.rulechecked=!1,t;if(!t.isshowline&&h.showrule&&(o=="CP"||o=="IP"||o=="ACP"||o=="AIP"))return this.adderror(t.n,"justification","high","cites a show-rule for a non-show-line"),t.rulechecked=!1,t;if(t.isshowline)(s.length>0||r.length>0)&&this.adderror(t.n,"justification","low","cites line numbers but show lines should not");else{let a;if(h.forms?a=h.forms.map(u=>{var p;return h.replacementrule?1:((p=u==null?void 0:u.prems)==null?void 0:p.length)??0}):a=[0],a.indexOf(s.length)==-1&&(this.adderror(t.n,"justification","low","cites the wrong number of lines for the rule specified"),s.length<a[0]&&!this.thorough))return t.rulechecked=!1,t;let l;if(h.forms?l=h.forms.map(u=>{var p;return((p=u==null?void 0:u.subderivs)==null?void 0:p.length)??0}):l=[0],l.indexOf(r.length)==-1&&(this.adderror(t.n,"justification","low","cites the wrong number of subderivation line ranges for the rule specified"),r.length<l[0]&&!this.thorough))return t.rulechecked=!1,t}return t.citednums=s,t.citedrangenums=r,t.rulechecked=o,t}checkRule(t){var h,a,l,u,p,c;const s=this.Formula;t.citedlines=t.citednums.map(f=>{var m,d;return((d=(m=this==null?void 0:this.deriv)==null?void 0:m.lines)==null?void 0:d[parseInt(f)-1])??!1}).filter(f=>f!==!1),t.citedsubderivs=t.citedrangenums.map(([f,m])=>{var d,y,v;return((v=(y=(d=this==null?void 0:this.deriv)==null?void 0:d.lines)==null?void 0:y[f-1])==null?void 0:v.mysubderiv)??!1}).filter(f=>f!==!1),t.isshowline&&t.mysubderiv&&t.citedsubderivs.push(t.mysubderiv);const r=t.rulechecked,e=this.rules[r]??!1;if(!e)return this.adderror(t.n,"rule","high","rule information for “"+r+"” found"),t;if(e!=null&&e.premiserule){const f=s.from(t.s).normal;let m=!1;for(let d of this.prems)if(d==f){m=!0;break}return m?t.checkedOK=!0:this.adderror(t.n,"rule","high","cited premise not among premises given for problem"),t}if(e!=null&&e.assumptionrule&&!this.numberedShowLines)return t.mysubderiv.assumptions.push(s.from(t.s).normal),t.checkedOK=!0,t;if(e!=null&&e.replacementrule){const f=new L(e,r,t,s).result();return f.success?t.checkedOK=!0:this.adderror(t.n,"rule","high",f.message),t}const i=(e==null?void 0:e.forms)??[];if(e.assumptionrule){let f=(h=t==null?void 0:t.mysubderiv)==null?void 0:h.showline;for(;f;){if(f.rulechecked&&this.rules[f.rulechecked]&&this.rules[f.rulechecked].showrule&&this.rules[f.rulechecked].forms){for(const m of this.rules[f.rulechecked].forms)if(m.subderivs){for(const d of m.subderivs)if(d.allows){let y={conc:d.allows};m.conc&&(y.prems=[m.conc]),t.citedlines.push(f),i.push(y)}}}f=(l=(a=f==null?void 0:f.mysubderiv)==null?void 0:a.parentderiv)==null?void 0:l.showline}}let n="";e.assumptionrule&&i.length==0&&(n="Assumption used outside a type of derivation that allows assumptions.");for(const f of i){const m=new A(e,r,f,t,s),d=m.result();if(d.success){let y=!0,v="";if("notinhyps"in f)for(const b of f.notinhyps){if("vacuous"in m&&"subst"in f){let x=!1;for(const k of m.vacuous)if(k in f.subst&&f.subst[k]==b){x=!0;break}if(x)continue}if((u=m==null?void 0:m.assigns)!=null&&u[b]&&((c=(p=m==null?void 0:m.assigns)==null?void 0:p[b])==null?void 0:c.length)>0){const x=m.assigns[b][0];for(let k=1;k<t.n;k++){let w=this.deriv.lnmap[k.toString()];if(this.isAvailableLineTo(k,t,!1)){if(!(w!=null&&w.j)||!(w!=null&&w.s)||!(w!=null&&w.rulechecked))continue;const j=this.rules[w.rulechecked];if(!(j!=null&&j.premiserule)&&!(j!=null&&j.assumptionrule))continue;if(s.from(w.s).terms.indexOf(x)!=-1){y=!1,v=x;break}}}}}return y?(t.checkedOK=!0,t):(this.adderror(t.n,"rule","high","the line applies the rule "+r+" using the name “"+v+"”, which occurs in an undischarged premise or assumption, and this is not allowed"),t)}d.message&&(n=d.message)}if(n==""){n="the line";let f="is";t.citedlines.length>0&&(f="are",t.citedsubderivs.length>0?n+=", the lines it cites,":n+=" and those it cites"),t.citedsubderivs.length&&(f="are"),n+=" "+f+" not of the right form for "+this.rulechecked+" to apply"}const o=t.isshowline&&n.indexOf("what is needed")!=-1?"completion":"rule";return this.adderror(t.n,o,"high",n),t}checkDeriv(t){const s=this.Formula;if(t.lines){for(const r of t.lines){const e=s.from(r.s);if(!e.wellformed)if(r.s.trim()==""){this.adderror(r.n,"completion","medium","formula field left blank");continue}else this.adderror(r.n,"syntax","low",e.syntaxerrors);this.checkJustification(r)}for(const r of t.lines)r!=null&&r.rulechecked&&this.checkRule(r)}}isAvailableLineTo(t,s,r=!0){var o,h;const e=t-1;if(this.deriv.lines.length<t||e<0)return r&&this.adderror(s.n,"justification","low","cites a line that does not exist"),!1;if(parseInt(s.n)==t)return r&&this.adderror(s.n,"justification","high","cites its own line number"),!1;if(parseInt(s.n)<t)return r&&this.adderror(s.n,"justification","high","cites a line later in the derivation"),!1;const i=this.deriv.lines[e];let n=s;for(;n;){if(n.isshowline){n=this.mysubderiv;continue}let a;n.parentderiv?a=n.parentderiv:a=n.mysubderiv;const l=((o=a==null?void 0:a.parts)==null?void 0:o.indexOf(n))??0;if(l>0)n=((h=a==null?void 0:a.parts)==null?void 0:h[l-1])??!1;else{if((a==null?void 0:a.showline)==i)return r&&this.adderror(s.n,"justification","high","cites a show line it is itself being used to demonstrate"),!1;if(a){n=a;continue}else{n=!1;break}}if(n.parts){if(n.showline&&i==n.showline)return!0;continue}if(n.n&&parseInt(n.n)<t)return r&&this.adderror(s.n,"justification","high","cites a line within a subderivation that is no longer available"),!1;if(n==i)return!0}return r&&this.adderror(s.n,"justification","high","cites a line within a subderivation that is no longer available"),!1}isAvailableRangeTo(t,s,r){var u,p;const e=t-1,i=s-1;if(e<0||i<0||t>this.deriv.lines.length||e>this.deriv.lines.length)return this.adderror(r.n,"justification","low","cites a non-existent range of lines"),!1;if(parseInt(r.n)>=t&&parseInt(r.n)<=s)return this.adderror(r.n,"justification","high","cites a range of lines in which it is included"),!1;if(parseInt(r.n)<=s)return this.adderror(r.n,"justification","high","cites a range of lines later in the derviation"),!1;const n=this.deriv.lines[e],o=this.deriv.lines[i],h=n.mysubderiv;if(h.lines.indexOf(o)==-1)return this.adderror(r.n,"justification","high","cites a range of lines that spans multiple subderivations"),!1;let a=!0;if(n.mysubderiv.lines[0]!=n&&(this.adderror(r.n,"justification","medium","line number given for start of range not at the start of a subderivation"),a=!1),h.lines[h.lines.length-1]!=o&&(this.adderror(r.n,"justification","medium","line number given for end of range not at the end of a subderivation"),a=!1),!a)return!1;let l=r;for(;l;){let c;l.parentderiv?c=l.parentderiv:c=l.mysubderiv;const f=((u=c==null?void 0:c.parts)==null?void 0:u.indexOf(l))??0;if(f>0)l=((p=c==null?void 0:c.parts)==null?void 0:p[f-1])??!1;else{if(c){l=c;continue}l=!1;break}if(l==h)return!0;if(l.n&&parseInt(l.n)<t)return this.adderror(r.n,"justification","high","cites a line range within a subderivation that is no longer available"),!1}return this.adderror(r.n,"justification","high","cites the main derivation as if it were a subderivation"),!1}lncheck(){for(let t=0;t<this.deriv.lines.length;t++){const s=this.deriv.lines[t];s.pos=t,s.n&&s.n!=""&&parseInt(s.n)-1!=s.pos&&this.adderror(s.n,"justification","low","does not have the right line number for its position")}return this.deriv}report(){return this.analyze(this.deriv),this.lncheck(),this.checkDeriv(this.deriv),this.traceBadDeps(),this.checkConc(),this.thorough&&this.weighErrors(),{lines:this.deriv.lines,lnmap:this.deriv.lnmap,pointsportion:this.pointsportion,errors:this.errors}}traceBadDeps(){for(const t in this.deriv.lnmap){const s=this.deriv.lnmap[t];let r=[];if(this.errors[t]&&(r=Object.keys(this.errors[t])),!(r.length>0))if(s.isshowline){let e=!1,i=!0;for(const n of s.mysubderiv.lines){if(n==s||!this.errors[n.n])continue;const o=Object.keys(this.errors[n.n]);if(o.length==1&&o[0]=="completion"){e=!0;continue}if(o.length>0){this.adderror(t,"dependency","low","contains errors in its subderivation, so may not be correct"),i=!0;break}}e&&!i&&this.adderror(t,"completion","low","depends on one or more incomplete subderivations")}else{if(s.citednums&&s.citednums.length!=0)for(const e of s.citednums){if(!this.errors[e])continue;if(Object.keys(this.errors[e]).length>0){this.adderror(t,"dependency","low","depends on a line that contains errors, so may not be correct");break}}if(s.citedsubderivs&&s.citedsubderivs.length!=0){t:for(const e of s.citedsubderivs)if("lnmap"in e)for(const i in e.lnmap){if(!this.errors[i])continue;if(Object.keys(this.errors[i]).length>0){this.adderror(t,"dependency","low","depends on a subderivation that contains errors, so may not be correct");break t}}}}}}weighErrors(){t:for(const t in this.errors)for(const s of["high","medium","low"])e:for(const r in this.errors[t]){if(r=="dependency"||!(s in this.errors[t][r]))continue e;for(let e in this.errors[t][r][s]){if(this.pointsportion=this.pointsportion-this.amts[s],this.pointsportion<0){this.pointsportion=0;break t}continue t}}return this}}class A{constructor(t,s,r,e,i){this.rule=t,this.rulename=s,this.form=r,this.Formula=i,this.syntax=this.Formula.syntax,this.message="",this.line=e,this.resultf=i.from(e.s),this.assigns={},this.possible=!0}checkConc(){const t=this.Formula;if(!this.form.conc)return;const s=t.from(this.form.conc);this.extendAssign(s,this.resultf,this.assigns)||(this.possible=!1,this.message="formula at this line not of the right form to result from "+this.rulename)}checkDiffersBy(){var p;if(!((p=this.form)!=null&&p.differsatmostby))return!0;const t=this.Formula,s=this.form.differsatmostby[0],r=this.form.differsatmostby[1],e=this.form.differsatmostby[2],i=this.form.differsatmostby[3];if(!(s in this.assigns))return!0;const n=t.from(this.assigns[s]);if(!(r in this.assigns))return!0;const o=t.from(this.assigns[r]);if(!(e in this.assigns))return!0;const h=this.assigns[e];if(!(i in this.assigns))return!0;const a=this.assigns[i],l={};let u=[];for(const c of h){const f=[];for(const m of a)t.differsAtMostBy(n,o,c,m)&&f.push(m);f.length>0&&(l[c]=f,u=_(u,f))}return this.assigns[e]=Object.keys(l),this.assigns[i]=u,this.assigns[e].length==0?(this.possible=!1,this.message!=""&&(this.message+="; "),this.message+="the formula "+this.assigns[s]+" does not differ from "+this.assigns[r]+" only by the substitution of the one term for the other",!1):!0}checkNewness(){var t,s,r,e;if(!((t=this.form)!=null&&t.mustbenew))return!0;for(const i of this.form.mustbenew){if(!((s=this==null?void 0:this.assigns)!=null&&s[i])||((e=(r=this==null?void 0:this.assigns)==null?void 0:r[i])==null?void 0:e.length)<1)continue;const n=this.assigns[i][0];if(n&&!this.isNewAt(n,this.line))return!1}return!0}checkPrems(){const t=this.Formula;if(!this.form.prems)return;const s=this.form.prems.map(n=>t.from(n)),r=this.line.citedlines.slice(0,s.length).map(n=>t.from(n.s));for(;r.length<s.length;)r.push(r[0]);const e=q(r.length);let i=!1;for(const n of e){const o={...this.assigns};let h=!0;for(let a=0;a<s.length;a++){const l=s[a],u=r[n[a]];if(!u){h=!1;break}if(this.extendAssign(l,u,o)===!1){h=!1;break}}if(h){i=!0,this.assigns=o;break}}i||(this.possible=!1,this.rule.assumptionrule?this.message="makes an assumption that is not allowed by the type of derivation":this.message="cited lines are not of the right form to support this line by "+this.rulename)}checkUI(){if(this.rulename!="UI"||!this.possible)return;const t=this.Formula,s=this.line.citedlines[0];if(!s||!s.s){this.possible=!1,this.message="UI requires citing a universal statement.";return}const r=t.from(s.s);if(r.op!=t.syntax.symbols.FORALL){this.possible=!1,this.message="UI requires a ∀-statement as the premise.";return}const e=r.boundvar,i=r.right,n=this.resultf,o=n.terms||[],h=[...new Set([...o,e])];let a=!1;for(const l of h){const u=i.instantiate(e,l);if(t.from(u).normal==n.normal){a=!0;break}}a||(this.possible=!1,this.message="conclusion is not a uniform substitution instance.")}checkUG(){if(this.rulename!="UG")return;const t=this.Formula,s=this.resultf;if(s.op!=t.syntax.symbols.FORALL){this.possible=!1,this.message="UG requires a ∀-statement as the conclusion.";return}s.boundvar;const r=s.right;if(!this.line.citedlines||this.line.citedlines.length==0){this.possible=!1,this.message="UG requires citing a line.";return}const e=this.line.citedlines[0];if(!e||!e.s){this.possible=!1,this.message="UG requires citing a line with a formula.";return}t.from(e.s).normal==r.normal?(this.possible=!0,this.message=""):(this.possible=!1,this.message="cited line does not contain the formula without the quantifier.")}checkRestrictions(){const t=this.Formula;if(!("cannotbein"in this.form))return!0;for(const s in this.form.cannotbein){if(!(s in this.assigns))continue;if("vacuous"in this&&"subst"in this.form){let i=!1;for(const n in this.form.subst)if(this.vacuous.indexOf(n)!=-1&&this.form.subst[n]==s){i=!0;break}if(i)continue}const r=this.assigns[s],e=this.form.cannotbein[s];for(const i of r)for(const n of e){if(!(n in this.assigns))continue;const o=this.assigns[n];if(t.from(o).terms.indexOf(i)!=-1)return this.message!=""&&(this.message+="; "),this.message+="applies the rule "+this.rulename+" using the term “"+i+"” in a line it is not allowed to occur in for that rule to apply.",this.possible=!1,!1}}return!0}checkSubDerivs(){var n;const t=this.Formula;if(!this.form.subderivs||this.form.subderivs.length==0)return;const s=this.line.citedsubderivs.slice(0,this.form.subderivs.length);for(;s.length<this.form.subderivs.length;)s.push(s[0]);const r=q(this.form.subderivs.length);let e=!1,i=!1;t:for(const o of r){let h={...this.assigns};e:for(let a=0;a<this.form.subderivs.length;a++){const l=this.form.subderivs[a],u=s[o[a]],p={...h};if(((n=u==null?void 0:u.assumptions)==null?void 0:n.length)>0)for(const f of u.assumptions){if(!("allows"in l))continue t;const m=t.from(l.allows);if(!this.extendAssign(m,t.from(f),p))continue t}let c=[[]];for(let f=0;f<l.needs.length;f++){const m=[];for(const d of c)for(const y of u.lines)m.push([...d,y]);c=m}s:for(const f of c){let m={...p};for(let d=0;d<l.needs.length;d++){const y=l.needs[d],v=t.from(y),b=f[d];if(b==this.line||!b.isshowline&&b.mysubderiv!=u||b.isshowline&&b.mysubderiv.parentderiv!=u||l.subshowrequired&&!b.isshowline||!this.extendAssign(v,t.from(b.s),m))continue s;let k=!0;if(l.wantsasnew)for(const w of l.wantsasnew){if(!(w in m)||m[w].length<1)continue;const j=m[w][0];if(!this.isNewAt(j,b)){k=!1;break}}if(!k){i=!0;continue s}}h=m;continue e}continue t}e=!0,this.assigns=h;break t}if(!e){if(this.line.isshowline){let o="what is needed to complete a derivation by "+this.rulename+" for this line not found in the subderivation";i&&(o+=" — did you remember to use a new name?"),(!(this!=null&&this.message)||this.message=="")&&(this.message=o)}else this.line.citedsubderivs.length>1?this.message="the cited subderivations do not contain what is necessary to show this line by "+this.rulename:this.message="the cited subderivation does not contain what is necessary to show this line by "+this.rulename;this.possible=!1}return e}extendAssign(t,s,r){var n;const e=this.Formula,i=this.syntax;if(t.op){if(t.op!=s.op)return!1;if(t.boundvar){if(!s.boundvar)return!1;if(t.boundvar in r){if(r[t.boundvar]!=s.boundvar)return!1}else r[t.boundvar]=s.boundvar}return!(t.left&&(!s.left||this.extendAssign(t.left,s.left,r)===!1)||t.right&&(!s.right||this.extendAssign(t.right,s.right,r)===!1))}if(t.normal in r){if(r[t.normal]!=s.normal)return!1}else r[t.normal]=s.normal;if(t.pletter=="="||t.pletter=="≠"){if(!s.pletter||s.pletter!=t.pletter||t.terms.length!=s.terms.length)return!1;for(let o=0;o<t.terms.length;o++){const h=t.terms[o],a=s.terms[o];if(i.isvar(h))if(h in r){if(r[h]!=a)return!1}else r[h]=a;else{if(h in r&&r[h].indexOf(a)==-1)return!1;r[h]=[a]}}}for(const o of t.terms)if(i.isvar(o)){if(this.form.subst&&o in this.form.subst){const h=this.form.subst[o];for(const a in r)if(a==t.instantiate(o,h)&&o in r)if(s.freevars.indexOf(r[o])==-1)if(s.normal==r[a])"vacuous"in this||(this.vacuous=[]),this.vacuous.push(o);else return!1;else{const l=r[h].filter(u=>r[a]==s.instantiate(r[o],u));if(l.length==0)return!1;r[h]=l}}}else{const h=_(["✪"],s.terms.filter(a=>!i.isvar(a)));if(o in r?r[o]=r[o].filter(a=>h.indexOf(a)!=-1):r[o]=h,(n=this==null?void 0:this.form)!=null&&n.subst){for(const a in this.form.subst)if(this.form.subst[a]==o&&a in r)for(const l in r){if(l.at(0)!=t.pletter)continue;const u=e.from(l);if(u.freevars.indexOf(a)==-1||t.normal!=u.instantiate(a,o))continue;const p=e.from(r[l]);if(p.freevars.indexOf(r[a])==-1){if(p.normal==s.normal)"vacuous"in this||(this.vacuous=[]),this.vacuous.push(a);else return!1;continue}if(r[o]=r[o].filter(c=>p.instantiate(r[a],c)==s.normal),r[o].length==0)return!1}}}return!0}isNewAt(t,s){var i,n;const r=this.Formula;let e=s;for(;e;){let o;e.parentderiv?o=e.parentderiv:o=e.mysubderiv;const h=((i=o==null?void 0:o.parts)==null?void 0:i.indexOf(e))??0;if(h>0)e=((n=o==null?void 0:o.parts)==null?void 0:n[h-1])??!1;else{if(o!=null&&o.showline&&o.showline!=s&&r.from(o.showline.s).terms.indexOf(t)!==-1)return!1;if(o){e=o;continue}e=!1;break}if(e.parts){if(e.showline&&r.from(e.showline.s).terms.indexOf(t)!==-1)return!1;continue}if(e.s&&r.from(e.s).terms.indexOf(t)!==-1)return!1}return!0}result(){return this.checkConc(),this.checkPrems(),this.checkSubDerivs(),this.checkDiffersBy(),this.checkRestrictions(),this.checkUI(),this.checkUG(),this.checkNewness()||(this.message!=""&&(this.message+="; "),this.message+="does not use a new name as is required by "+this.rulename,this.possible=!1),{success:this.possible,message:this.message}}}class L{constructor(t,s,r,e){this.rule=t,this.rulename=s,this.line=r,this.Formula=e,this.message=""}differsFromBy(t,s,r){const e=this.Formula,i=e.from(t),n=e.from(s);if(i.normal==n.normal)return 0;const[o,h]=this.pseudolines(t,s),a=new A(this.rule,this.rulename,{prems:[r.a],conc:r.b},o,this.Formula),l=new A(this.rule,this.rulename,{prems:[r.b],conc:r.a},o,this.Formula);if(a.checkConc(),a.checkPrems(),l.checkConc(),l.checkPrems(),a.possible||l.possible)return 1;if(i.op&&!n.op||!i.op&&n.op||!i.op&&!n.op||i.op!=n.op||i.boundvar&&i.boundvar!=n.boundvar||e.syntax.ispropconst(i.op)||!i.right||!n.right)return-1;const u=i.right.normal,p=n.right.normal,c=this.differsFromBy(u,p,r);if(c==-1)return-1;if(e.syntax.ismonop(i.op))return c;if(!i.left||!n.left)return-1;const f=i.left.normal,m=n.left.normal,d=this.differsFromBy(f,m,r);return d==-1?-1:d+c}pseudolines(t,s){const r={s,isshowline:!1};return[{s:t,isshowline:!1,citedlines:[r]},r]}result(){if(this.line.citedlines.length<1)return{success:!1,message:"does not cite a line to be equivalent with"};for(const t of this.rule.forms)if(this.differsFromBy(this.line.s,this.line.citedlines[0].s,t)==1)return{success:!0,message:this.message};return{success:!1,message:"line is not of the right form to result from the cited line by "+this.rulename}}}let I="hardegree";var C;typeof process<"u"&&((C=process==null?void 0:process.appsettings)!=null&&C.defaultnotation)&&(I=process.appsettings.defaultnotation);function F(g,t,s){let r=0;if(!("parts"in g))return 0;for(let e of g.parts){if("parts"in e)if(r+=F(e,t,s),"showline"in e)e=e.showline;else continue;if(!("n"in e)||!("j"in e))continue;if(e.n in t){let o=!1;for(let h in t[e.n])if(h!="dependency"){o=!0;break}if(o)continue}const{citedrules:i}=S(e.j);if(i.length<1)continue;const n=i[0];n in s&&(s[n].assumptionrule||s[n].showrule||/O/.test(n))&&r++}return r}async function z(g,t,s,r,e,i){const n=JSON.parse(JSON.stringify(s)),o=(i==null?void 0:i.notation)??I,h=R(),a=new N(o,h,n,g.prems,g.conc,r,!0).report(),l=Object.keys(a.errors).length==0;let u=1;if(r&&!l&&t){const p=a.pointsportion;u=p;const c=F(t,{},h),f=F(s,a.errors,h);if(c>0){const m=f/c;if(p<.5){let d=f*.1;d>.5&&(d=.5),u=Math.max(p,d)}m<.8&&(u=u*m),e=Math.floor(u*e)}}else e=l?e:0;return{successstatus:l?"correct":"incorrect",errors:a.errors,points:e}}export{z as default};
